searchState.loadedDescShard("governor", 0, "governor - a rate-limiting library for rust.\nA rate limiter representing a single item of state in …\nA rate limiter with one state per key, running on the …\nError indicating that the number of cells tested (the first\nAn interval specification for deviating from the nominal …\nA negative rate-limiting outcome.\nA rate-limiting quota.\nA rate limiter.\nA more in-depth guide to <code>governor</code>\nAdjusts the maximum burst size for a quota to construct a …\nThe maximum number of cells that can be allowed in one …\nThe time it takes to replenish the entire maximum burst …\nAllow a single cell through the rate limiter.\nAllow a single cell through the rate limiter for the given …\nAllow <em>only all</em> <code>n</code> cells through the rate limiter for the …\nAllow <em>only all</em> <code>n</code> cells through the rate limiter.\nTime sources for rate limiters.\nConstructs a new keyed rate limiter explicitly backed by a …\nConstructs a new rate limiter with a custom clock, backed …\nConstructs a new rate limiter with a custom clock and …\nConstructs a new keyed rate limiter explicitly backed by a …\nConstructs a new in-memory direct rate limiter for a quota …\nConstructs a new direct rate limiter for a quota with a …\nReturns the earliest time at which a decision could be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new keyed rate limiter explicitly backed by a …\nConstructs a new rate limiter with a custom clock, backed …\nConstructs a new rate limiter with a custom clock and …\nConstructs a new keyed rate limiter explicitly backed by a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the rate limiter has no keys in it.\nConstructs a new keyed rate limiter backed by the …\nReturns the number of “live” keys in the rate limiter…\nAdditional, customizable behavior for rate limiters.\nA time-keeping abstraction (nanoseconds) that works for …\nConstructs a new Jitter interval, waiting at least <code>min</code> and …\nConstruct a quota for a given burst size, replenishing the …\nConstruct a quota for a number of cells per 60-minute …\nConstruct a quota for a number of cells per 60-second …\nConstruct a quota for a number of cells per second. The …\nThe collection of asynchronous traits exported from this …\nReturns the rate limiting <code>Quota</code> used to reach the decision.\nThe time it takes for a rate limiter with an exhausted …\nRetains all keys in the rate limiter that were used …\nShrinks the capacity of the rate limiter’s state store, …\nState stores for rate limiters\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nAsynchronously resolves as soon as the rate limiter allows …\nConstructs a new Jitter interval, waiting at most a …\nReturns the minimum amount of time from the time that the …\nConstruct a quota that replenishes one cell in a given …\nA time source used by rate limiters.\nThe default clock using <code>quanta</code> for extremely fast …\nA mock implementation of a clock. All it does is keep …\nA measurement of a monotonically increasing clock.\nThe monotonic clock implemented by <code>Instant</code>.\nA clock using the default <code>quanta::Clock</code> structure.\nA nanosecond-scale opaque instant (already scaled to …\nA clock using the default <code>quanta::Clock</code> structure and an …\nIdentifies clocks that run similarly to the monotonic …\nA measurement from a clock.\nThe non-monotonic clock implemented by <code>SystemTime</code>.\nAdvances the fake clock by the given amount.\nDetermines the time that separates two measurements of a …\nCompares two fake relative clocks’ current state, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a new <code>QuantaUpkeepClock</code> with an upkeep thread as …\nReturns a new <code>QuantaUpkeepClock</code> with an upkeep thread that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a measurement of the clock.\nReturns a reference point at the start of an operation.\nReturns a reference point at the start of an operation.\nReturns a reference point that lies at most <code>duration</code> in the\nThe type that’s returned by the rate limiter when a cell …\nA middleware that does nothing and returns <code>()</code> in the …\nThe type that’s returned by the rate limiter when a cell …\nDefines the behavior and return values of rate limiting …\nMiddleware that returns the state of the rate limiter if a …\nInformation about the rate-limiting state used to reach a …\nCalled when a positive rate-limiting decision is made.\nReturns <code>()</code> and has no side-effects.\nCalled when a negative rate-limiting decision is made (the …\nReturns the error indicating what\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the quota used to make the rate limiting decision.\nReturns the number of cells that can be let through in …\nA number of nanoseconds from a reference point.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn in-memory representation of a GCRA’s rate-limiting …\nThe type of key that the state store can represent.\nA rate limiter.\nA way for rate limiters to keep state.\nReturns a reference to the clock.\nDirect rate limiters (those that can only hold one state).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConsumes the <code>RateLimiter</code> and returns the state store.\nKeyed rate limiters (those that can hold one state per …\nUpdates a state store’s rate limiting state for a given …\nCreates a new rate limiter from components.\nConvert the given rate limiter into one that uses a …\nA trait for state stores that only keep one rate limiting …\nThe value given to state stores’ methods.\nThe “this state store does not use keys” key type.\nA <code>Sink</code> combinator that only allows sending elements when …\nA <code>Stream</code> combinator which will limit the rate of items …\nAllows converting a <code>futures_util::Sink</code> combinator into a …\nAllows converting a <code>futures_util::Stream</code> combinator into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAcquires a mutable reference to the underlying sink that …\nAcquires a mutable reference to the underlying stream that …\nAcquires a reference to the underlying sink that this …\nAcquires a reference to the underlying stream that this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this combinator, returning the underlying sink.\nConsumes this combinator, returning the underlying stream …\nLimits the rate at which items can be put into the current …\nLimits the rate at which items can be put into the current …\nLimits the rate at which the stream produces items.\nLimits the rate at which the stream produces items, with a …\nA concurrent, thread-safe and fairly performant hashmap …\nThe default keyed rate limiter type: the concurrent <code>DashMap</code>…\nA thread-safe (but not very performant) implementation of …\nA trait for state stores with one rate limiting state per …\nKeyed rate limiters that can be “cleaned up”.\nReturns <code>true</code> if <code>self</code> has no keys stored in it.\nReturns the number of “live” keys stored in the state …\nRemove those keys with state older than <code>drop_below</code>.\nShrinks the capacity of the state store, if possible.")