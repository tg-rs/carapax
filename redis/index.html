<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="redis-rs is a Rust implementation of a client library for Redis.  It exposes a general purpose interface to Redis and also provides specific helpers for commonly used functionality."><title>redis - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="redis" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0-nightly (e3843659e 2025-07-04)" data-channel="nightly" data-search-js="search-179e01a3.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-673ee1e0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../redis/index.html">redis</a><span class="version">0.32.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basic-operation" title="Basic Operation">Basic Operation</a></li><li><a href="#tls--ssl" title="TLS / SSL">TLS / SSL</a></li><li><a href="#tcp-settings" title="TCP settings">TCP settings</a><ul><li><a href="#connection-handling" title="Connection Handling">Connection Handling</a></li><li><a href="#connection-pooling" title="Connection Pooling">Connection Pooling</a></li><li><a href="#optional-features" title="Optional Features">Optional Features</a></li><li><a href="#connection-parameters" title="Connection Parameters">Connection Parameters</a></li><li><a href="#executing-low-level-commands" title="Executing Low-Level Commands">Executing Low-Level Commands</a></li><li><a href="#executing-high-level-commands" title="Executing High-Level Commands">Executing High-Level Commands</a></li><li><a href="#type-conversions" title="Type Conversions">Type Conversions</a></li><li><a href="#pre-typed-commands" title="Pre-typed Commands">Pre-typed Commands</a></li></ul></li><li><a href="#resp3-support" title="RESP3 support">RESP3 support</a></li><li><a href="#iteration-protocol" title="Iteration Protocol">Iteration Protocol</a></li><li><a href="#pipelining" title="Pipelining">Pipelining</a></li><li><a href="#transactions" title="Transactions">Transactions</a></li><li><a href="#pubsub" title="PubSub">PubSub</a><ul><li><a href="#resp3-async-pubsub" title="RESP3 async pubsub">RESP3 async pubsub</a></li></ul></li><li><a href="#scripts" title="Scripts">Scripts</a></li><li><a href="#async" title="Async">Async</a><ul><li><a href="#runtime-support" title="Runtime support">Runtime support</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>redis</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/redis/lib.rs.html#1-750">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>redis-rs is a Rust implementation of a client library for Redis.  It exposes
a general purpose interface to Redis and also provides specific helpers for
commonly used functionality.</p>
<p>The crate is called <code>redis</code> and you can depend on it via cargo:</p>
<div class="example-wrap"><pre class="language-ini"><code>[dependencies.redis]
version = &quot;*&quot;</code></pre></div>
<p>If you want to use the git version:</p>
<div class="example-wrap"><pre class="language-ini"><code>[dependencies.redis]
git = &quot;https://github.com/redis-rs/redis-rs.git&quot;</code></pre></div><h2 id="basic-operation"><a class="doc-anchor" href="#basic-operation">§</a>Basic Operation</h2>
<p>redis-rs exposes two API levels: a low- and a high-level part.
The high-level part does not expose all the functionality of redis and
might take some liberties in how it speaks the protocol.  The low-level
part of the API allows you to express any request on the redis level.
You can fluently switch between both API levels at any point.</p>
<h2 id="tls--ssl"><a class="doc-anchor" href="#tls--ssl">§</a>TLS / SSL</h2>
<p>The user can enable TLS support using either RusTLS or native support (usually OpenSSL),
using the <code>tls-rustls</code> or <code>tls-native-tls</code> features respectively. In order to enable TLS
for async usage, the user must enable matching features for their runtime - either <code>tokio-native-tls-comp</code>,
<code>tokio-rustls-comp</code>, <code>async-std-native-tls-comp</code>, or <code>async-std-rustls-comp</code>. Additionally, the
<code>tls-rustls-webpki-roots</code> allows usage of of webpki-roots for the root certificate store.</p>
<h2 id="tcp-settings"><a class="doc-anchor" href="#tcp-settings">§</a>TCP settings</h2>
<p>The user can set parameters of the underlying TCP connection by using the <code>tcp_nodelay</code> and <code>keep-alive</code> features.
Alternatively, users of async connections can set <a href="io/tcp/struct.TcpSettings.html" title="struct redis::io::tcp::TcpSettings">crate::io::tcp::TcpSettings</a> on the connection configuration objects,
and set the TCP parameters in a more specific manner there.</p>
<h3 id="connection-handling"><a class="doc-anchor" href="#connection-handling">§</a>Connection Handling</h3>
<p>For connecting to redis you can use a client object which then can produce
actual connections.  Connections and clients as well as results of
connections and clients are considered <code>ConnectionLike</code> objects and
can be used anywhere a request is made.</p>
<p>The full canonical way to get a connection is to create a client and
to ask for a connection from it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>redis;

<span class="kw">fn </span>do_something() -&gt; redis::RedisResult&lt;()&gt; {
    <span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>con = client.get_connection()<span class="question-mark">?</span>;

    <span class="comment">/* do something here */

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="connection-pooling"><a class="doc-anchor" href="#connection-pooling">§</a>Connection Pooling</h3>
<p>When using a sync connection, it is recommended to use a connection pool in order to handle
disconnects or multi-threaded usage. This can be done using the <code>r2d2</code> feature.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>redis::Commands;

<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>).unwrap();
<span class="kw">let </span>pool = r2d2::Pool::builder().build(client).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>conn = pool.get().unwrap();

<span class="kw">let _</span>: () = conn.set(<span class="string">"KEY"</span>, <span class="string">"VALUE"</span>).unwrap();
<span class="kw">let </span>val: String = conn.get(<span class="string">"KEY"</span>).unwrap();</code></pre></div>
<p>For async connections, connection pooling isn’t necessary. The <code>MultiplexedConnection</code> is
cheap to clone and can be used safely concurrently from multiple threads, so a single connection can be easily
reused. For automatic reconnections consider using <code>ConnectionManager</code> with the <code>connection-manager</code> feature.
Async cluster connections also don’t require pooling and are thread-safe and reusable.</p>
<h3 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional Features</h3>
<p>There are a few features defined that can enable additional functionality
if so desired.  Some of them are turned on by default.</p>
<ul>
<li><code>acl</code>: enables acl support (enabled by default)</li>
<li><code>tokio-comp</code>: enables support for async usage with the Tokio runtime (optional)</li>
<li><code>async-std-comp</code>: enables support for async usage with any runtime which is async-std compliant. (optional)</li>
<li><code>smol-comp</code>: enables support for async usage with the Smol runtime (optional)</li>
<li><code>geospatial</code>: enables geospatial support (enabled by default)</li>
<li><code>script</code>: enables script support (enabled by default)</li>
<li><code>streams</code>: enables high-level interface for interaction with Redis streams (enabled by default)</li>
<li><code>r2d2</code>: enables r2d2 connection pool support (optional)</li>
<li><code>ahash</code>: enables ahash map/set support &amp; uses ahash internally (+7-10% performance) (optional)</li>
<li><code>cluster</code>: enables redis cluster support (optional)</li>
<li><code>cluster-async</code>: enables async redis cluster support (optional)</li>
<li><code>connection-manager</code>: enables support for automatic reconnection (optional)</li>
<li><code>keep-alive</code>: enables keep-alive option on socket by means of <code>socket2</code> crate (enabled by default)</li>
<li><code>tcp_nodelay</code>: enables the no-delay flag on  communication sockets (optional)</li>
<li><code>rust_decimal</code>, <code>bigdecimal</code>, <code>num-bigint</code>: enables type conversions to large number representation from different crates (optional)</li>
<li><code>uuid</code>: enables type conversion to UUID (optional)</li>
<li><code>sentinel</code>: enables high-level interfaces for communication with Redis sentinels (optional)</li>
<li><code>json</code>: enables high-level interfaces for communication with the JSON module (optional)</li>
<li><code>cache-aio</code>: enables <strong>experimental</strong> client side caching for MultiplexedConnection, ConnectionManager and async ClusterConnection (optional)</li>
<li><code>disable-client-setinfo</code>: disables the <code>CLIENT SETINFO</code> handshake during connection initialization</li>
</ul>
<h3 id="connection-parameters"><a class="doc-anchor" href="#connection-parameters">§</a>Connection Parameters</h3>
<p>redis-rs knows different ways to define where a connection should
go.  The parameter to <code>Client::open</code> needs to implement the
<code>IntoConnectionInfo</code> trait of which there are three implementations:</p>
<ul>
<li>string slices in <code>redis://</code> URL format.</li>
<li>URL objects from the redis-url crate.</li>
<li><code>ConnectionInfo</code> objects.</li>
</ul>
<p>The URL format is <code>redis://[&lt;username&gt;][:&lt;password&gt;@]&lt;hostname&gt;[:port][/[&lt;db&gt;][?protocol=&lt;protocol&gt;]]</code></p>
<p>If Unix socket support is available you can use a unix URL in this format:</p>
<p><code>redis+unix:///&lt;path&gt;[?db=&lt;db&gt;[&amp;pass=&lt;password&gt;][&amp;user=&lt;username&gt;][&amp;protocol=&lt;protocol&gt;]]</code></p>
<p>For compatibility with some other libraries for Redis, the “unix” scheme
is also supported:</p>
<p><code>unix:///&lt;path&gt;[?db=&lt;db&gt;][&amp;pass=&lt;password&gt;][&amp;user=&lt;username&gt;][&amp;protocol=&lt;protocol&gt;]]</code></p>
<h3 id="executing-low-level-commands"><a class="doc-anchor" href="#executing-low-level-commands">§</a>Executing Low-Level Commands</h3>
<p>To execute low-level commands you can use the <code>cmd</code> function which allows
you to build redis requests.  Once you have configured a command object
to your liking you can send a query into any <code>ConnectionLike</code> object:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;()&gt; {
    redis::cmd(<span class="string">"SET"</span>).arg(<span class="string">"my_key"</span>).arg(<span class="number">42</span>).exec(con)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Upon querying the return value is a result object.  If you do not care
about the actual return value (other than that it is not a failure)
you can always type annotate it to the unit type <code>()</code>.</p>
<p>Note that commands with a sub-command (like “MEMORY USAGE”, “ACL WHOAMI”,
“LATENCY HISTORY”, etc) must specify the sub-command as a separate <code>arg</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;usize&gt; {
    <span class="comment">// This will result in a server error: "unknown command `MEMORY USAGE`"
    // because "USAGE" is technically a sub-command of "MEMORY".
    </span>redis::cmd(<span class="string">"MEMORY USAGE"</span>).arg(<span class="string">"my_key"</span>).query::&lt;usize&gt;(con)<span class="question-mark">?</span>;

    <span class="comment">// However, this will work as you'd expect
    </span>redis::cmd(<span class="string">"MEMORY"</span>).arg(<span class="string">"USAGE"</span>).arg(<span class="string">"my_key"</span>).query(con)
}</code></pre></div>
<h3 id="executing-high-level-commands"><a class="doc-anchor" href="#executing-high-level-commands">§</a>Executing High-Level Commands</h3>
<p>The high-level interface is similar.  For it to become available you
need to use the <code>Commands</code> trait in which case all <code>ConnectionLike</code>
objects the library provides will also have high-level methods which
make working with the protocol easier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>redis;
<span class="kw">use </span>redis::Commands;

<span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;()&gt; {
    <span class="kw">let _</span>: () = con.set(<span class="string">"my_key"</span>, <span class="number">42</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Note that high-level commands are work in progress and many are still
missing!</p>
<h3 id="type-conversions"><a class="doc-anchor" href="#type-conversions">§</a>Type Conversions</h3>
<p>Because redis inherently is mostly type-less and the protocol is not
exactly friendly to developers, this library provides flexible support
for casting values to the intended results.  This is driven through the <code>FromRedisValue</code> and <code>ToRedisArgs</code> traits.</p>
<p>The <code>arg</code> method of the command will accept a wide range of types through
the <code>ToRedisArgs</code> trait and the <code>query</code> method of a command can convert the
value to what you expect the function to return through the <code>FromRedisValue</code>
trait.  This is quite flexible and allows vectors, tuples, hashsets, hashmaps
as well as optional values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>count : i32 = con.get(<span class="string">"my_counter"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>count = con.get(<span class="string">"my_counter"</span>).unwrap_or(<span class="number">0i32</span>);
<span class="kw">let </span>k : <span class="prelude-ty">Option</span>&lt;String&gt; = con.get(<span class="string">"missing_key"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>name : String = con.get(<span class="string">"my_name"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bin : Vec&lt;u8&gt; = con.get(<span class="string">"my_binary"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>map : HashMap&lt;String, i32&gt; = con.hgetall(<span class="string">"my_hash"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>keys : Vec&lt;String&gt; = con.hkeys(<span class="string">"my_hash"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>mems : HashSet&lt;i32&gt; = con.smembers(<span class="string">"my_set"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(k1, k2) : (String, String) = con.get(<span class="kw-2">&amp;</span>[<span class="string">"k1"</span>, <span class="string">"k2"</span>])<span class="question-mark">?</span>;</code></pre></div>
<h3 id="pre-typed-commands"><a class="doc-anchor" href="#pre-typed-commands">§</a>Pre-typed Commands</h3>
<p>In some cases, you may not have a desired return type for a high-level command, and would
instead like to use defaults provided by the library, to avoid the clutter and development overhead
of specifying types for each command.</p>
<p>The library facilitates this by providing the <code>TypedCommands</code> and <code>AsyncTypedCommands</code>
as alternatives to <code>Commands</code> and <code>AsyncCommands</code> respectively. These traits provide functions
with pre-defined and opinionated return types. For example, <code>set</code> returns <code>()</code>, avoiding the need
for developers to explicitly type each call as returning <code>()</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>redis::TypedCommands;

<span class="kw">fn </span>fetch_an_integer() -&gt; redis::RedisResult&lt;isize&gt; {
    <span class="comment">// connect to redis
    </span><span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>con = client.get_connection()<span class="question-mark">?</span>;
    <span class="comment">// `set` returns a `()`, so we don't need to specify the return type manually unlike in the previous example.
    </span>con.set(<span class="string">"my_key"</span>, <span class="number">42</span>)<span class="question-mark">?</span>;
    <span class="comment">// `get_int` returns Result&lt;Option&lt;isize&gt;&gt;, as the key may not be found, or some error may occur.
    </span><span class="prelude-val">Ok</span>(con.get_int(<span class="string">"my_key"</span>).unwrap().unwrap())
}</code></pre></div>
<h2 id="resp3-support"><a class="doc-anchor" href="#resp3-support">§</a>RESP3 support</h2>
<p>Since Redis / Valkey version 6, a newer communication protocol called RESP3 is supported.
Using this protocol allows the user both to receive a more varied <code>Value</code> results, for users
who use the low-level <code>Value</code> type, and to receive out of band messages on the same connection. This allows the user to receive PubSub
messages on the same connection, instead of creating a new PubSub connection (see “RESP3 async pubsub”).</p>
<h2 id="iteration-protocol"><a class="doc-anchor" href="#iteration-protocol">§</a>Iteration Protocol</h2>
<p>In addition to sending a single query, iterators are also supported.  When
used with regular bulk responses they don’t give you much over querying and
converting into a vector (both use a vector internally) but they can also
be used with <code>SCAN</code> like commands in which case iteration will send more
queries until the cursor is exhausted:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter : redis::Iter&lt;isize&gt; = redis::cmd(<span class="string">"SSCAN"</span>).arg(<span class="string">"my_set"</span>)
    .cursor_arg(<span class="number">0</span>).clone().iter(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;
<span class="kw">for </span>x <span class="kw">in </span>iter {
    <span class="comment">// do something with the item
</span>}</code></pre></div>
<p>As you can see the cursor argument needs to be defined with <code>cursor_arg</code>
instead of <code>arg</code> so that the library knows which argument needs updating
as the query is run for more items.</p>
<h2 id="pipelining"><a class="doc-anchor" href="#pipelining">§</a>Pipelining</h2>
<p>In addition to simple queries you can also send command pipelines.  This
is provided through the <code>pipe</code> function.  It works very similar to sending
individual commands but you can send more than one in one go.  This also
allows you to ignore individual results so that matching on the end result
is easier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_1"</span>).arg(<span class="number">42</span>).ignore()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_2"</span>).arg(<span class="number">43</span>).ignore()
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_1"</span>)
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<p>If you want the pipeline to be wrapped in a <code>MULTI</code>/<code>EXEC</code> block you can
easily do that by switching the pipeline into <code>atomic</code> mode.  From the
caller’s point of view nothing changes, the pipeline itself will take
care of the rest for you:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_1"</span>).arg(<span class="number">42</span>).ignore()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_2"</span>).arg(<span class="number">43</span>).ignore()
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_1"</span>)
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<p>You can also use high-level commands on pipelines:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .set(<span class="string">"key_1"</span>, <span class="number">42</span>).ignore()
    .set(<span class="string">"key_2"</span>, <span class="number">43</span>).ignore()
    .get(<span class="string">"key_1"</span>)
    .get(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="transactions"><a class="doc-anchor" href="#transactions">§</a>Transactions</h2>
<p>Transactions are available through atomic pipelines.  In order to use
them in a more simple way you can use the <code>transaction</code> function of a
connection:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>redis::Commands;
<span class="kw">let </span>key = <span class="string">"the_key"</span>;
<span class="kw">let </span>(new_val,) : (isize,) = redis::transaction(<span class="kw-2">&amp;mut </span>con, <span class="kw-2">&amp;</span>[key], |con, pipe| {
    <span class="kw">let </span>old_val : isize = con.get(key)<span class="question-mark">?</span>;
    pipe
        .set(key, old_val + <span class="number">1</span>).ignore()
        .get(key).query(con)
})<span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"The incremented number is: {}"</span>, new_val);</code></pre></div>
<p>For more information see the <code>transaction</code> function.</p>
<h2 id="pubsub"><a class="doc-anchor" href="#pubsub">§</a>PubSub</h2>
<p>Pubsub is provided through the <code>PubSub</code> connection object for sync usage, or the <code>aio::PubSub</code>
for async usage.</p>
<p>Example usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_connection()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>pubsub = con.as_pubsub();
pubsub.subscribe(<span class="kw-2">&amp;</span>[<span class="string">"channel_1"</span>, <span class="string">"channel_2"</span>])<span class="question-mark">?</span>;

<span class="kw">loop </span>{
    <span class="kw">let </span>msg = pubsub.get_message()<span class="question-mark">?</span>;
    <span class="kw">let </span>payload : String = msg.get_payload()<span class="question-mark">?</span>;
    <span class="macro">println!</span>(<span class="string">"channel '{}': {}"</span>, msg.get_channel_name(), payload);
}</code></pre></div>
<p>In order to update subscriptions while concurrently waiting for messages, the async PubSub can be split into separate sink &amp; stream components. The sink can be receive subscription requests while the stream is awaited for messages.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_util::StreamExt;
<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>sink, <span class="kw-2">mut </span>stream) = client.get_async_pubsub().<span class="kw">await</span><span class="question-mark">?</span>.split();
sink.subscribe(<span class="string">"channel_1"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">loop </span>{
    <span class="kw">let </span>msg = stream.next().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>payload : String = msg.get_payload().unwrap();
    <span class="macro">println!</span>(<span class="string">"channel '{}': {}"</span>, msg.get_channel_name(), payload);
}</code></pre></div>
<h3 id="resp3-async-pubsub"><a class="doc-anchor" href="#resp3-async-pubsub">§</a>RESP3 async pubsub</h3>
<p>If you’re targeting a Redis/Valkey server of version 6 or above, you can receive
pubsub messages from it without creating another connection, by setting a push sender on the connection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/?protocol=resp3"</span>).unwrap();
<span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx) = tokio::sync::mpsc::unbounded_channel();
<span class="kw">let </span>config = redis::AsyncConnectionConfig::new().set_push_sender(tx);
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_multiplexed_async_connection_with_config(<span class="kw-2">&amp;</span>config).<span class="kw">await</span><span class="question-mark">?</span>;
con.subscribe(<span class="kw-2">&amp;</span>[<span class="string">"channel_1"</span>, <span class="string">"channel_2"</span>]).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">loop </span>{
  <span class="macro">println!</span>(<span class="string">"Received {:?}"</span>, rx.recv().<span class="kw">await</span>.unwrap());
}</code></pre></div>
<h2 id="scripts"><a class="doc-anchor" href="#scripts">§</a>Scripts</h2>
<p>Lua scripts are supported through the <code>Script</code> type in a convenient
way.  It will automatically load the script if it does not exist and invoke it.</p>
<p>Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>script = redis::Script::new(<span class="string">r"
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
"</span>);
<span class="kw">let </span>result: isize = script.arg(<span class="number">1</span>).arg(<span class="number">2</span>).invoke(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(result, <span class="number">3</span>);</code></pre></div>
<p>Scripts can also be pipelined:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>script = redis::Script::new(<span class="string">r"
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
"</span>);
<span class="kw">let </span>(a, b): (isize, isize) = redis::pipe()
    .invoke_script(script.arg(<span class="number">1</span>).arg(<span class="number">2</span>))
    .invoke_script(script.arg(<span class="number">2</span>).arg(<span class="number">3</span>))
    .query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(b, <span class="number">5</span>);</code></pre></div>
<p>Note: unlike a call to <a href="struct.ScriptInvocation.html#method.invoke" title="method redis::ScriptInvocation::invoke"><code>invoke</code></a>, if the script isn’t loaded during the pipeline operation,
it will not automatically be loaded and retried. The script can be loaded using the
<a href="struct.ScriptInvocation.html#method.load" title="method redis::ScriptInvocation::load"><code>load</code></a> operation.</p>
<h2 id="async"><a class="doc-anchor" href="#async">§</a>Async</h2>
<p>In addition to the synchronous interface that’s been explained above there also exists an
asynchronous interface based on <a href="https://crates.io/crates/futures"><code>futures</code></a> and <a href="https://tokio.rs"><code>tokio</code></a>, <a href="https://docs.rs/smol/latest/smol/"><code>smol</code></a>, or <a href="https://async.rs/"><code>async-std</code></a>.
All async connections are cheap to clone, and clones can be used concurrently from multiple threads.</p>
<p>This interface exists under the <code>aio</code> (async io) module (which requires that the <code>aio</code> feature
is enabled) and largely mirrors the synchronous with a few concessions to make it fit the
constraints of <code>futures</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>redis::AsyncCommands;

<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_multiplexed_async_connection().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let _</span>: () = con.set(<span class="string">"key1"</span>, <span class="string">b"foo"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

redis::cmd(<span class="string">"SET"</span>).arg(<span class="kw-2">&amp;</span>[<span class="string">"key2"</span>, <span class="string">"bar"</span>]).exec_async(<span class="kw-2">&amp;mut </span>con).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let </span>result = redis::cmd(<span class="string">"MGET"</span>)
 .arg(<span class="kw-2">&amp;</span>[<span class="string">"key1"</span>, <span class="string">"key2"</span>])
 .query_async(<span class="kw-2">&amp;mut </span>con)
 .<span class="kw">await</span>;
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>((<span class="string">"foo"</span>.to_string(), <span class="string">b"bar"</span>.to_vec())));</code></pre></div>
<h3 id="runtime-support"><a class="doc-anchor" href="#runtime-support">§</a>Runtime support</h3>
<p>The crate supports multiple runtimes, including <code>tokio</code>, <code>async-std</code>, and <code>smol</code>. For Tokio, the crate will
spawn tasks on the current thread runtime. For async-std &amp; smol, the crate will spawn tasks on the the global runtime.
It is recommended that the crate be used with support only for a single runtime. If the crate is compiled with multiple runtimes,
the user should call [<code>crate::aio::prefer_tokio</code>], [<code>crate::aio::prefer_async_std</code>] or [<code>crate::aio::prefer_smol</code>] to set the preferred runtime.
These functions set global state which automatically chooses the correct runtime for the async connection.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="acl/index.html" title="mod redis::acl">acl</a></dt><dd>Defines types to use with the ACL commands.</dd><dt><a class="mod" href="aio/index.html" title="mod redis::aio">aio</a></dt><dd>Adds async IO support to redis.</dd><dt><a class="mod" href="geo/index.html" title="mod redis::geo">geo</a></dt><dd>Defines types to use with the geospatial commands.</dd><dt><a class="mod" href="io/index.html" title="mod redis::io">io</a></dt><dd>Module for defining I/O behavior.</dd><dt><a class="mod" href="streams/index.html" title="mod redis::streams">streams</a></dt><dd>Defines types to use with the streams commands.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AsyncConnectionConfig.html" title="struct redis::AsyncConnectionConfig">Async<wbr>Connection<wbr>Config</a></dt><dd>Options for creation of async connection</dd><dt><a class="struct" href="struct.AsyncIter.html" title="struct redis::AsyncIter">Async<wbr>Iter</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Represents a redis iterator that can be used with async connections.</dd><dt><a class="struct" href="struct.Client.html" title="struct redis::Client">Client</a></dt><dd>The client type.</dd><dt><a class="struct" href="struct.Cmd.html" title="struct redis::Cmd">Cmd</a></dt><dd>Represents redis commands.</dd><dt><a class="struct" href="struct.Connection.html" title="struct redis::Connection">Connection</a></dt><dd>Represents a stateful redis TCP connection.</dd><dt><a class="struct" href="struct.ConnectionInfo.html" title="struct redis::ConnectionInfo">Connection<wbr>Info</a></dt><dd>Holds the connection information that redis should use for connecting.</dd><dt><a class="struct" href="struct.CopyOptions.html" title="struct redis::CopyOptions">Copy<wbr>Options</a></dt><dd>Options for the <a href="https://redis.io/commands/copy">COPY</a> command</dd><dt><a class="struct" href="struct.FlushAllOptions.html" title="struct redis::FlushAllOptions">Flush<wbr>AllOptions</a></dt><dd>Options for the <a href="https://redis.io/commands/flushall">FLUSHALL</a> command</dd><dt><a class="struct" href="struct.HashFieldExpirationOptions.html" title="struct redis::HashFieldExpirationOptions">Hash<wbr>Field<wbr>Expiration<wbr>Options</a></dt><dd>Options for the HSETEX command</dd><dt><a class="struct" href="struct.InfoDict.html" title="struct redis::InfoDict">Info<wbr>Dict</a></dt><dd>An info dictionary type.</dd><dt><a class="struct" href="struct.Iter.html" title="struct redis::Iter">Iter</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Represents a redis iterator.</dd><dt><a class="struct" href="struct.LposOptions.html" title="struct redis::LposOptions">Lpos<wbr>Options</a></dt><dd>Options for the <a href="https://redis.io/commands/lpos">LPOS</a> command</dd><dt><a class="struct" href="struct.Msg.html" title="struct redis::Msg">Msg</a></dt><dd>Represents a pubsub message.</dd><dt><a class="struct" href="struct.Parser.html" title="struct redis::Parser">Parser</a></dt><dd>The internal redis response parser.</dd><dt><a class="struct" href="struct.Pipeline.html" title="struct redis::Pipeline">Pipeline</a></dt><dd>Represents a redis command pipeline.</dd><dt><a class="struct" href="struct.PubSub.html" title="struct redis::PubSub">PubSub</a></dt><dd>Represents a pubsub connection.</dd><dt><a class="struct" href="struct.PushInfo.html" title="struct redis::PushInfo">Push<wbr>Info</a></dt><dd>A push message from the server.</dd><dt><a class="struct" href="struct.RedisConnectionInfo.html" title="struct redis::RedisConnectionInfo">Redis<wbr>Connection<wbr>Info</a></dt><dd>Redis specific/connection independent information used to establish a connection to redis.</dd><dt><a class="struct" href="struct.RedisError.html" title="struct redis::RedisError">Redis<wbr>Error</a></dt><dd>Represents a redis error.</dd><dt><a class="struct" href="struct.ReplicaInfo.html" title="struct redis::ReplicaInfo">Replica<wbr>Info</a></dt><dd>Replication information for a replica, as returned by the <a href="https://redis.io/docs/latest/commands/role/"><code>ROLE</code></a> command.</dd><dt><a class="struct" href="struct.ScanOptions.html" title="struct redis::ScanOptions">Scan<wbr>Options</a></dt><dd>Options for the <a href="https://redis.io/commands/scan">SCAN</a> command</dd><dt><a class="struct" href="struct.Script.html" title="struct redis::Script">Script</a></dt><dd>Represents a lua script.</dd><dt><a class="struct" href="struct.ScriptInvocation.html" title="struct redis::ScriptInvocation">Script<wbr>Invocation</a></dt><dd>Represents a prepared script call.</dd><dt><a class="struct" href="struct.SetOptions.html" title="struct redis::SetOptions">SetOptions</a></dt><dd>Options for the <a href="https://redis.io/commands/set">SET</a> command</dd><dt><a class="struct" href="struct.SortedSetAddOptions.html" title="struct redis::SortedSetAddOptions">Sorted<wbr>SetAdd<wbr>Options</a></dt><dd>Options for the <a href="https://redis.io/commands/zadd">ZADD</a> command</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Arg.html" title="enum redis::Arg">Arg</a></dt><dd>An argument to a redis command</dd><dt><a class="enum" href="enum.ConnectionAddr.html" title="enum redis::ConnectionAddr">Connection<wbr>Addr</a></dt><dd>Defines the connection address.</dd><dt><a class="enum" href="enum.ControlFlow.html" title="enum redis::ControlFlow">Control<wbr>Flow</a></dt><dd>Allows pubsub callbacks to stop receiving messages.</dd><dt><a class="enum" href="enum.Direction.html" title="enum redis::Direction">Direction</a></dt><dd>Enum for the LEFT | RIGHT args used by some commands</dd><dt><a class="enum" href="enum.ErrorKind.html" title="enum redis::ErrorKind">Error<wbr>Kind</a></dt><dd>An enum of all error kinds.</dd><dt><a class="enum" href="enum.ExistenceCheck.html" title="enum redis::ExistenceCheck">Existence<wbr>Check</a></dt><dd>Helper enum that is used to define existence checks</dd><dt><a class="enum" href="enum.ExpireOption.html" title="enum redis::ExpireOption">Expire<wbr>Option</a></dt><dd>Helper enum that is used to define option for the hash expire commands</dd><dt><a class="enum" href="enum.Expiry.html" title="enum redis::Expiry">Expiry</a></dt><dd>Helper enum that is used to define expiry time</dd><dt><a class="enum" href="enum.FieldExistenceCheck.html" title="enum redis::FieldExistenceCheck">Field<wbr>Existence<wbr>Check</a></dt><dd>Helper enum that is used to define field existence checks</dd><dt><a class="enum" href="enum.IntegerReplyOrNoOp.html" title="enum redis::IntegerReplyOrNoOp">Integer<wbr>Reply<wbr>OrNo<wbr>Op</a></dt><dd>Returned by typed commands which either return a positive integer or some negative integer indicating some kind of no-op.</dd><dt><a class="enum" href="enum.NumericBehavior.html" title="enum redis::NumericBehavior">Numeric<wbr>Behavior</a></dt><dd>Helper enum that is used in some situations to describe
the behavior of arguments in a numeric context.</dd><dt><a class="enum" href="enum.ProtocolVersion.html" title="enum redis::ProtocolVersion">Protocol<wbr>Version</a></dt><dd>Enum representing the communication protocol with the server.</dd><dt><a class="enum" href="enum.PushKind.html" title="enum redis::PushKind">Push<wbr>Kind</a></dt><dd><code>Push</code> type’s currently known kinds.</dd><dt><a class="enum" href="enum.RetryMethod.html" title="enum redis::RetryMethod">Retry<wbr>Method</a></dt><dd>What method should be used if retrying this request.</dd><dt><a class="enum" href="enum.Role.html" title="enum redis::Role">Role</a></dt><dd>High level representation of response to the <a href="https://redis.io/docs/latest/commands/role/"><code>ROLE</code></a> command.</dd><dt><a class="enum" href="enum.SetExpiry.html" title="enum redis::SetExpiry">SetExpiry</a></dt><dd>Helper enum that is used to define expiry time for SET command</dd><dt><a class="enum" href="enum.TlsMode.html" title="enum redis::TlsMode">TlsMode</a></dt><dd>TlsMode indicates use or do not use verification of certification.</dd><dt><a class="enum" href="enum.UpdateCheck.html" title="enum redis::UpdateCheck">Update<wbr>Check</a></dt><dd>Helper enum that is used to define update checks</dd><dt><a class="enum" href="enum.Value.html" title="enum redis::Value">Value</a></dt><dd>Internal low-level redis value enum.</dd><dt><a class="enum" href="enum.ValueType.html" title="enum redis::ValueType">Value<wbr>Type</a></dt><dd>Possible types of value held in Redis: <a href="https://redis.io/docs/latest/commands/type/">Redis Docs</a></dd><dt><a class="enum" href="enum.VerbatimFormat.html" title="enum redis::VerbatimFormat">Verbatim<wbr>Format</a></dt><dd><code>VerbatimString</code>’s format types defined by spec</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AsyncCommands.html" title="trait redis::AsyncCommands">Async<wbr>Commands</a></dt><dd>Implements common redis commands over asynchronous connections.</dd><dt><a class="trait" href="trait.AsyncTypedCommands.html" title="trait redis::AsyncTypedCommands">Async<wbr>Typed<wbr>Commands</a></dt><dd>Implements common redis commands over asynchronous connections.
The return types are concrete and opinionated. If you want to choose the return type you should use the <code>AsyncCommands</code> trait.</dd><dt><a class="trait" href="trait.Commands.html" title="trait redis::Commands">Commands</a></dt><dd>Implements common redis commands for connection like objects.</dd><dt><a class="trait" href="trait.ConnectionLike.html" title="trait redis::ConnectionLike">Connection<wbr>Like</a></dt><dd>Implements the “stateless” part of the connection interface that is used by the
different objects in redis-rs.</dd><dt><a class="trait" href="trait.FromRedisValue.html" title="trait redis::FromRedisValue">From<wbr>Redis<wbr>Value</a></dt><dd>This trait is used to convert a redis value into a more appropriate
type.</dd><dt><a class="trait" href="trait.IntoConnectionInfo.html" title="trait redis::IntoConnectionInfo">Into<wbr>Connection<wbr>Info</a></dt><dd>Converts an object into a connection info struct.  This allows the
constructor of the client to accept connection information in a
range of different formats.</dd><dt><a class="trait" href="trait.PubSubCommands.html" title="trait redis::PubSubCommands">PubSub<wbr>Commands</a></dt><dd>The PubSub trait allows subscribing to one or more channels
and receiving a callback whenever a message arrives.</dd><dt><a class="trait" href="trait.RedisWrite.html" title="trait redis::RedisWrite">Redis<wbr>Write</a></dt><dd>Abstraction trait for redis command abstractions.</dd><dt><a class="trait" href="trait.ToRedisArgs.html" title="trait redis::ToRedisArgs">ToRedis<wbr>Args</a></dt><dd>Used to convert a value into one or multiple redis argument
strings.  Most values will produce exactly one item but in
some cases it might make sense to produce more than one.</dd><dt><a class="trait" href="trait.TypedCommands.html" title="trait redis::TypedCommands">Typed<wbr>Commands</a></dt><dd>Implements common redis commands.
The return types are concrete and opinionated. If you want to choose the return type you should use the <code>Commands</code> trait.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.cmd.html" title="fn redis::cmd">cmd</a></dt><dd>Shortcut function to creating a command with a single argument.</dd><dt><a class="fn" href="fn.from_owned_redis_value.html" title="fn redis::from_owned_redis_value">from_<wbr>owned_<wbr>redis_<wbr>value</a></dt><dd>A shortcut function to invoke <code>FromRedisValue::from_owned_redis_value</code>
to make the API slightly nicer.</dd><dt><a class="fn" href="fn.from_redis_value.html" title="fn redis::from_redis_value">from_<wbr>redis_<wbr>value</a></dt><dd>A shortcut function to invoke <code>FromRedisValue::from_redis_value</code>
to make the API slightly nicer.</dd><dt><a class="fn" href="fn.make_extension_error.html" title="fn redis::make_extension_error">make_<wbr>extension_<wbr>error</a></dt><dd>Creates a new Redis error with the <code>ExtensionError</code> kind.</dd><dt><a class="fn" href="fn.pack_command.html" title="fn redis::pack_command">pack_<wbr>command</a></dt><dd>Packs a bunch of commands into a request.</dd><dt><a class="fn" href="fn.parse_redis_url.html" title="fn redis::parse_redis_url">parse_<wbr>redis_<wbr>url</a></dt><dd>This function takes a redis URL string and parses it into a URL
as used by rust-url.</dd><dt><a class="fn" href="fn.parse_redis_value.html" title="fn redis::parse_redis_value">parse_<wbr>redis_<wbr>value</a></dt><dd>Parses bytes into a redis value.</dd><dt><a class="fn" href="fn.parse_redis_value_async.html" title="fn redis::parse_redis_value_async">parse_<wbr>redis_<wbr>value_<wbr>async</a></dt><dd>Parses a redis value asynchronously.</dd><dt><a class="fn" href="fn.pipe.html" title="fn redis::pipe">pipe</a></dt><dd>Shortcut for creating a new pipeline.</dd><dt><a class="fn" href="fn.transaction.html" title="fn redis::transaction">transaction</a></dt><dd>This function simplifies transaction management slightly.  What it
does is automatically watching keys and then going into a transaction
loop util it succeeds.  Once it goes through the results are
returned.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.FlushDbOptions.html" title="type redis::FlushDbOptions">Flush<wbr>DbOptions</a></dt><dd>Options for the <a href="https://redis.io/commands/flushdb">FLUSHDB</a> command</dd><dt><a class="type" href="type.RedisFuture.html" title="type redis::RedisFuture">Redis<wbr>Future</a></dt><dd>Library generic future type.</dd><dt><a class="type" href="type.RedisResult.html" title="type redis::RedisResult">Redis<wbr>Result</a></dt><dd>Library generic result type.</dd></dl></section></div></main></body></html>